/**
 * @blaze-sql/wasm - WebAssembly bindings for Blaze SQL query engine
 *
 * @example
 * ```typescript
 * import { BlazeDB, initBlaze } from '@blaze-sql/wasm';
 *
 * // Initialize the WASM module
 * await initBlaze();
 *
 * // Create a connection
 * const db = new BlazeDB();
 *
 * // Register data
 * db.registerCsv('users', 'id,name\n1,Alice\n2,Bob');
 *
 * // Query the data
 * const result = db.query('SELECT * FROM users WHERE id = 1');
 * console.log(result.rows);
 * // [{ id: 1, name: 'Alice' }]
 * ```
 */

// Import types for the WASM module (generated by wasm-pack)
// These will be available after running wasm-pack build
interface WasmModule {
  WasmConnection: new () => WasmConnectionInstance;
  memory: WebAssembly.Memory;
}

interface WasmConnectionInstance {
  execute(sql: string): number;
  query(sql: string): string;
  query_with_options(sql: string, options: string): string;
  load_json(table_name: string, json: string): number;
  drop_table(table_name: string): void;
  list_tables(): string[];
  table_schema(table_name: string): string | null;
  stats(): string;
  clear(): void;
  free(): void;
}

let wasmModule: WasmModule | null = null;

/**
 * Column information for query results
 */
export interface ColumnInfo {
  name: string;
  type: string;
  nullable: boolean;
}

/**
 * Query result from the database
 */
export interface QueryResult {
  /** Array of row objects */
  rows: Record<string, unknown>[];
  /** Column metadata */
  columns: ColumnInfo[];
  /** Number of rows returned */
  rowCount: number;
  /** Execution time in milliseconds */
  executionTimeMs: number;
}

/**
 * Query options for customizing result format
 */
export interface QueryOptions {
  /** Maximum number of rows to return */
  maxRows?: number;
  /** Output format */
  format?: 'json' | 'csv' | 'arrow';
  /** Include schema information */
  includeSchema?: boolean;
  /** Pretty print output (JSON only) */
  pretty?: boolean;
}

/**
 * Database configuration options
 */
export interface DBConfig {
  /** Maximum memory limit in bytes */
  maxMemory?: number;
  /** Maximum result size in bytes */
  maxResultSize?: number;
  /** Enable query logging */
  enableLogging?: boolean;
}

/**
 * Database statistics
 */
export interface DBStats {
  queriesExecuted: number;
  totalQueryTimeMs: number;
  memoryUsed: number;
  peakMemory: number;
  tableCount: number;
  totalRows: number;
}

/**
 * Table schema information
 */
export interface TableSchema {
  columns: ColumnInfo[];
}

/**
 * Initialize the Blaze WASM module
 *
 * Must be called before creating any BlazeDB instances.
 * In browser environments, this fetches and instantiates the WASM module.
 *
 * @example
 * ```typescript
 * await initBlaze();
 * const db = new BlazeDB();
 * ```
 */
export async function initBlaze(): Promise<void> {
  if (wasmModule) {
    return; // Already initialized
  }

  // Dynamic import of the WASM module
  // The actual path will be resolved based on the bundler configuration
  try {
    const wasm = await import('../pkg/blaze');
    await wasm.default();
    wasmModule = wasm as unknown as WasmModule;
  } catch (error) {
    throw new Error(`Failed to initialize Blaze WASM: ${error}`);
  }
}

/**
 * Check if the WASM module is initialized
 */
export function isInitialized(): boolean {
  return wasmModule !== null;
}

/**
 * BlazeDB - Main database connection class
 *
 * Provides a JavaScript-friendly interface to the Blaze SQL query engine
 * running in WebAssembly.
 *
 * @example
 * ```typescript
 * const db = new BlazeDB();
 *
 * // Register JSON data
 * db.registerJson('users', [
 *   { id: 1, name: 'Alice' },
 *   { id: 2, name: 'Bob' }
 * ]);
 *
 * // Run a query
 * const result = db.query('SELECT * FROM users');
 * console.log(result.rows);
 * ```
 */
export class BlazeDB {
  private connection: WasmConnectionInstance | null = null;

  /**
   * Create a new database connection
   * @param config Optional configuration options
   */
  constructor(config?: DBConfig) {
    if (!wasmModule) {
      throw new Error('Blaze WASM not initialized. Call initBlaze() first.');
    }

    this.connection = new wasmModule.WasmConnection();

    // Apply configuration if provided
    if (config) {
      // Configuration is applied through the WASM layer
      // For now, we store it for future use
      console.debug('BlazeDB configuration:', config);
    }
  }

  /**
   * Execute a SQL statement (DDL like CREATE TABLE, DROP TABLE)
   * @param sql SQL statement to execute
   * @returns Number of rows affected
   */
  execute(sql: string): number {
    this.checkConnection();
    try {
      return this.connection!.execute(sql);
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Execute a SQL query and return results
   * @param sql SQL query to execute
   * @param options Optional query options
   * @returns Query result with rows and metadata
   */
  query(sql: string, options?: QueryOptions): QueryResult {
    this.checkConnection();

    try {
      let resultJson: string;

      if (options) {
        const optionsJson = JSON.stringify({
          max_rows: options.maxRows,
          format: options.format ?? 'json',
          include_schema: options.includeSchema ?? true,
          pretty: options.pretty ?? false,
        });
        resultJson = this.connection!.query_with_options(sql, optionsJson);
      } else {
        resultJson = this.connection!.query(sql);
      }

      const result = JSON.parse(resultJson);

      return {
        rows: result.data ?? result,
        columns: result.schema ?? [],
        rowCount: result.row_count ?? (result.data ?? result).length,
        executionTimeMs: result.execution_time_ms ?? 0,
      };
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Execute a query and return results as an Arrow IPC buffer
   * @param sql SQL query to execute
   * @returns Uint8Array containing Arrow IPC data
   */
  queryArrow(sql: string): Uint8Array {
    this.checkConnection();

    try {
      const result = this.connection!.query_with_options(
        sql,
        JSON.stringify({ format: 'arrow_ipc' })
      );
      // The result is base64 encoded Arrow IPC data
      return Uint8Array.from(atob(result), (c) => c.charCodeAt(0));
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Register JSON data as a table
   * @param tableName Name for the new table
   * @param data Array of objects or JSON string
   * @returns Number of rows registered
   */
  registerJson(tableName: string, data: Record<string, unknown>[] | string): number {
    this.checkConnection();

    const jsonStr = typeof data === 'string' ? data : JSON.stringify(data);

    try {
      return this.connection!.load_json(tableName, jsonStr);
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Register CSV data as a table
   * @param tableName Name for the new table
   * @param csvData CSV string with headers
   * @returns Number of rows registered
   */
  registerCsv(tableName: string, csvData: string): number {
    this.checkConnection();

    // Convert CSV to JSON for the WASM layer
    const rows = this.parseCsv(csvData);
    return this.registerJson(tableName, rows);
  }

  /**
   * Drop a table from the database
   * @param tableName Name of the table to drop
   */
  dropTable(tableName: string): void {
    this.checkConnection();

    try {
      this.connection!.drop_table(tableName);
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * List all tables in the database
   * @returns Array of table names
   */
  listTables(): string[] {
    this.checkConnection();

    try {
      return this.connection!.list_tables();
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Get the schema of a table
   * @param tableName Name of the table
   * @returns Table schema or null if table doesn't exist
   */
  getTableSchema(tableName: string): TableSchema | null {
    this.checkConnection();

    try {
      const schemaJson = this.connection!.table_schema(tableName);
      if (!schemaJson) {
        return null;
      }
      return JSON.parse(schemaJson) as TableSchema;
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Get database statistics
   * @returns Current database statistics
   */
  getStats(): DBStats {
    this.checkConnection();

    try {
      const statsJson = this.connection!.stats();
      const stats = JSON.parse(statsJson);
      return {
        queriesExecuted: stats.queries_executed,
        totalQueryTimeMs: stats.total_query_time_ms,
        memoryUsed: stats.memory_used,
        peakMemory: stats.peak_memory,
        tableCount: stats.table_count,
        totalRows: stats.total_rows,
      };
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Clear all tables and reset the database
   */
  clear(): void {
    this.checkConnection();

    try {
      this.connection!.clear();
    } catch (error) {
      throw this.wrapError(error);
    }
  }

  /**
   * Close the database connection and free resources
   */
  close(): void {
    if (this.connection) {
      this.connection.free();
      this.connection = null;
    }
  }

  private checkConnection(): void {
    if (!this.connection) {
      throw new Error('Database connection is closed');
    }
  }

  private wrapError(error: unknown): Error {
    if (error instanceof Error) {
      return new Error(`BlazeDB Error: ${error.message}`);
    }
    return new Error(`BlazeDB Error: ${String(error)}`);
  }

  /**
   * Parse CSV string to array of objects
   */
  private parseCsv(csvData: string): Record<string, unknown>[] {
    const lines = csvData.trim().split('\n');
    if (lines.length === 0) {
      return [];
    }

    const headers = this.parseCsvLine(lines[0]);
    const rows: Record<string, unknown>[] = [];

    for (let i = 1; i < lines.length; i++) {
      const values = this.parseCsvLine(lines[i]);
      const row: Record<string, unknown> = {};

      for (let j = 0; j < headers.length; j++) {
        const value = values[j] ?? '';
        // Try to parse as number
        const numValue = Number(value);
        row[headers[j]] = isNaN(numValue) ? value : numValue;
      }

      rows.push(row);
    }

    return rows;
  }

  /**
   * Parse a single CSV line handling quoted values
   */
  private parseCsvLine(line: string): string[] {
    const result: string[] = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const char = line[i];

      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }

    result.push(current.trim());
    return result;
  }
}

// Re-export for convenience
export default BlazeDB;
